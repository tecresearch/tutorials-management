package com.hcl.turorial.controller;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.hcl.turorial.dto.TutorialRequest;
import com.hcl.turorial.dto.TutorialResponse;
import com.hcl.turorial.service.TutorialService;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class TutorialControllerTests {

    @MockBean
    private TutorialService tutorialService;
    @Autowired
    private MockMvc mockMvc;
/**
 * POST Method : /api/platform/v1/tutorials/create
 * Body : {"title":"%s", "description":"%s", "status":%b}
 */
    /** Method: 1
     * This test method verifies the creation of a tutorial through the API. It mocks the service layer,
     * performs a POST request with tutorial data, and validates the response.
     */
    @Test
    public void testCreateTutorial() throws Exception {
        /**
         * Given: Prepare a dummy TutorialResponse object representing a successful creation
         * that includes an auto-generated ID, a title, and a description. The ID is assumed
         * to be generated by the service or database layer.
         */
        TutorialResponse tutorialResponse = new TutorialResponse(1L, "Spring Boot", "By Brijesh Nishad",false);

        /**
         * Mocking the tutorialService to return the predefined tutorialResponse when the createTutorial method
         * is called with any TutorialRequest object. This simulates the service layer behavior after the ID
         er is generated.
         */
        when(tutorialService.createTutorial(any(TutorialRequest.class))).thenReturn(tutorialResponse);

        /**
         * When: Perform a POST request to the API endpoint for creating a tutorial. The request includes
         * the content type as JSON and a properly formatted JSON string as the payload. The ID is omitted
         * since it's auto-incremented and handled by the database.
         */
        mockMvc.perform(post("/api/platform/v1/tutorials/create")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\":\"Spring Boot\", \"description\":\"By Brijesh Nishad\",\"status\":false}")
                )
                /**
                 * Then: Assert that the response status is HTTP 201 Created, indicating the tutorial was created
                 * successfully.
                 */
                .andExpect(status().isCreated())
                /**
                 * Validate the returned JSON content against the expected values using jsonPath assertions.
                 * This checks the properties in the JSON response based on the tutorialResponse object.
                 */
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.title").value("Spring Boot"))
                .andExpect(jsonPath("$.description").value("By Brijesh Nishad"))
                .andExpect(jsonPath("$.status").value(false));
    }

    /** Method: 2
     * This test method verifies the creation of a tutorial through the API. It mocks the service layer,
     * performs a POST request with tutorial data, and validates the response.
     */

    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, By Brijesh Nishad, false",
            "2, Java, By John Doe, true"
    })
    public void testCreateTutorial(Long id, String title, String description, boolean status) throws Exception {
        // Arrange: Create TutorialResponse with parameters
        TutorialResponse tutorialResponse = new TutorialResponse(id, title, description, status);
        when(tutorialService.createTutorial(any(TutorialRequest.class))).thenReturn(tutorialResponse);

        // Act: Perform POST request with input parameters
        mockMvc.perform(post("/api/platform/v1/tutorials/create")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(String.format("{\"title\":\"%s\", \"description\":\"%s\", \"status\":%b}", title, description, status))
                )
                // Assert: Validate the response
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));
    }

    /** Method: 3
     * Using JSONObject for JSON Creation
     * You can utilize the JSONObject class from the JSON library to create your JSON payload in a more readable manner:
     * This test method verifies the creation of a tutorial through the API. It mocks the service layer,
     * performs a POST request with tutorial data, and validates the response.
     */


    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, By Brijesh Nishad, false",
            "2, Java, By John Doe, true"
    })
    public void testCreateTutorialJsons(Long id, String title, String description, boolean status) throws Exception {
        TutorialResponse tutorialResponse = new TutorialResponse(id, title, description, status);
        when(tutorialService.createTutorial(any(TutorialRequest.class))).thenReturn(tutorialResponse);

        JSONObject json = new JSONObject();
        json.put("title", title);
        json.put("description", description);
        json.put("status", status);

        mockMvc.perform(post("/api/platform/v1/tutorials/create")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(json.toString())
                )
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));
    }

    /** Method: 4
     * Using ObjectMapper to Convert a Map to JSON
     * You can utilize the JSONObject class from the JSON library to create your JSON payload in a more readable manner:
     * This test method verifies the creation of a tutorial through the API. It mocks the service layer,
     * performs a POST request with tutorial data, and validates the response.
     */
    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, By Brijesh Nishad, false",
            "2, Java, By John Doe, true",
            "3, Java, By John Doe, true",
            "4, Java, By John Doe, true",
            "5, Java, By John Doe, true"
    })
    public void testCreateTutorialJsonMap(Long id, String title, String description, boolean status) throws Exception {
        TutorialResponse tutorialResponse = new TutorialResponse(id, title, description, status);
        when(tutorialService.createTutorial(any(TutorialRequest.class))).thenReturn(tutorialResponse);

        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("title", title);
        jsonMap.put("description", description);
        jsonMap.put("status", status);
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonContent = objectMapper.writeValueAsString(jsonMap);

        mockMvc.perform(post("/api/platform/v1/tutorials/create")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonContent)
                )
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));
    }

    /**
     * GET Method : /api/platform/v1/tutorials/get/{id}
     * Header : @PathVariable("id")
     */


    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, By Brijesh Nishad, false",
            "2, Java, By John Doe, true"
    })
    public void testGetTutorialWithId(long id, String title, String description, boolean status) throws Exception {
        // Given: Create a TutorialResponse object for the parameter set
        TutorialResponse tutorialResponse = new TutorialResponse(id, title, description, status);

        // Mocking the service to return the TutorialResponse for the given ID
        when(tutorialService.getTutorialById(id)).thenReturn(tutorialResponse);

        // When: Perform a GET request to retrieve the tutorial
        mockMvc.perform(get("/api/platform/v1/tutorials/get/{id}", id)
                        .contentType(MediaType.APPLICATION_JSON)
                )
                // Then: Assert that the response status is OK and validate the returned JSON content
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));
    }


    /**
     * PUT METHOD : /api/platform/v1/tutorials/get/update/{id}
     * Header : @PathVariable("id")
     * Body: {" Spring Boot, By Brijesh Nishad, false"}
     */

    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, By Brijesh Nishad, false",
            "2, Java, By John Doe, true",
            "3, Java, By John Doe, true",
            "4, Java, By John Doe, true",
            "5, Java, By John Doe, true"
    })
    public void testUpdateTutorialWithId(long id, String title, String description, boolean status) throws Exception{
         TutorialResponse expectedTutorialResponse = new TutorialResponse(id, title, description, status);
         when(tutorialService.updateTutorial(anyLong(),any(TutorialRequest.class))).thenReturn(expectedTutorialResponse);

        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("title", title);
        jsonMap.put("description", description);
        jsonMap.put("status", status);
        ObjectMapper objectMapper = new ObjectMapper();
        String jsonContent = objectMapper.writeValueAsString(jsonMap);

        mockMvc.perform(put("/api/platform/v1/tutorials/update/{id}",id)
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonContent))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));

    }

    /**
     * Delete METHOD : /api/platform/v1/tutorials/get/delete/{id}
     * Header : @PathVariable("id")
     */

    @ParameterizedTest
    @CsvSource({
            "1",//parameter (...)
            "2",
            "3",
            "4",
            "5"
    })
     public void testDeleteTutorialWithId(long id) throws Exception {
        // Mocking the service layer (no need for a response for DELETE)
        // when(tutorialService.deleteTutorialById(id)); // Not needed, since it's a void method

        // Performing the DELETE request
        mockMvc.perform(delete("/api/platform/v1/tutorials/delete/{id}", id)
                        .contentType(MediaType.APPLICATION_JSON)
                )
                // Asserting the response status is NO_CONTENT
                .andExpect(status().isNoContent());

        // Verifying that the service method was called with the correct id
        verify(tutorialService).deleteTutorialById(id);
     }

    /**
     * PATCH METHOD : /api/platform/v1/tutorials/patch/update/{id}
     * Header : @PathVariable("id")
     * Body: {" Spring Boot, By Brijesh Nishad, false"}
     */

    @ParameterizedTest
    @CsvSource({
            "1, Spring Boot, Updated Description 1, false",
            "2, Java, Updated Description 2, true",
            "3, Python, Updated Description 3, false"
    })
    public void testPatchTutorial(long id, String title, String description, boolean status) throws Exception {


        // Create the expected TutorialResponse for the update
        TutorialResponse expectedTutorialResponse = new TutorialResponse(id, title, description, status);

        // Mock the service method to return the expected response for the update
        when(tutorialService.updateTutorial(anyLong(), any(TutorialRequest.class))).thenReturn(expectedTutorialResponse);

        // Preparing JSON content for the request
        ObjectMapper objectMapper = new ObjectMapper();
        // Create a TutorialRequest object from the parameters
        TutorialRequest tutorialRequest = new TutorialRequest(title, description, status);
        String jsonContent = objectMapper.writeValueAsString(tutorialRequest);

        // Performing the PATCH request
        mockMvc.perform(patch("/api/platform/v1/tutorials/patch/update/{id}", id)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonContent))
                // Asserting the response status and content
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(id))
                .andExpect(jsonPath("$.title").value(title))
                .andExpect(jsonPath("$.description").value(description))
                .andExpect(jsonPath("$.status").value(status));
    }


    /**
     * Options METHOD : /api/platform/v1/tutorials/options/{id}
     * Header : @PathVariable("id")
     */
    @ParameterizedTest
    @ValueSource(longs = {1, 2, 3})
    public void testOptionsTutorial(long id) throws Exception {
        // Performing the OPTIONS request
        mockMvc.perform(options("/api/platform/v1/tutorials/options/{id}", id)
                        .contentType(MediaType.APPLICATION_JSON)
                )
                // Asserting the response status is OK
                .andExpect(status().isOk());
    }


    /***
     * Now other remaining integration jUnit testing
     * which include : POST,GET,PUT,DELETE RequestMethod in RequestMapping for value /your-route/{id}
     */
    /**
     * List of Tutorials
     * @return
     */
// Method to provide test cases for parameterized tests
    private static Stream<List<TutorialResponse>> provideTutorials() {
        return Stream.of(
                Arrays.asList(
                        new TutorialResponse(1L, "Spring Boot", "By Brijesh Nishad", false),
                        new TutorialResponse(2L, "Java", "By John Doe", true)
                ),
                Arrays.asList(
                        new TutorialResponse(3L, "Python", "By Alice", false),
                        new TutorialResponse(4L, "JavaScript", "By Bob", true)
                )
        );
    }
    @ParameterizedTest
    @MethodSource("provideTutorials")
    public void testGetAllTutorials(List<TutorialResponse> tutorialResponses) throws Exception {
        // Mock the service method call to return the provided list
        when(tutorialService.getAllTutorials()).thenReturn(tutorialResponses);

        // Perform the GET request and assert the results
        mockMvc.perform(get("/api/platform/v1/tutorials/get-all")
                        .contentType(MediaType.APPLICATION_JSON)
                )
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].id").value(tutorialResponses.get(0).getId()))
                .andExpect(jsonPath("$[0].title").value(tutorialResponses.get(0).getTitle()))
                .andExpect(jsonPath("$[0].description").value(tutorialResponses.get(0).getDescription()))
                .andExpect(jsonPath("$[0].status").value(tutorialResponses.get(0).getStatus()))
                .andExpect(jsonPath("$[1].id").value(tutorialResponses.get(1).getId()))
                .andExpect(jsonPath("$[1].title").value(tutorialResponses.get(1).getTitle()))
                .andExpect(jsonPath("$[1].description").value(tutorialResponses.get(1).getDescription()))
                .andExpect(jsonPath("$[1].status").value(tutorialResponses.get(1).getStatus()));
    }

/**
 * Get Tutorial bassed on title
 */

    // Method to provide test cases for parameterized tests
    private static Stream<Arguments> provideTutorialTitles() {
        return Stream.of(
                Arguments.of("Spring Boot", new TutorialResponse(1L, "Spring Boot", "By Brijesh Nishad", false)),
                Arguments.of("Java", new TutorialResponse(2L, "Java", "By John Doe", true))
        );
    }

    @ParameterizedTest
    @MethodSource("provideTutorialTitles")
    public void testGetTutorialByTitle(String title, TutorialResponse expectedResponse) throws Exception {
        // Mock the service method call to return the expected tutorial response
        when(tutorialService.getTutorialByTitle(title)).thenReturn(expectedResponse);

        // Perform the GET request and assert the results
        mockMvc.perform(get("/api/platform/v1/tutorials/get")
                        .param("title", title)
                        .contentType(MediaType.APPLICATION_JSON)
                )
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(expectedResponse.getId()))
                .andExpect(jsonPath("$.title").value(expectedResponse.getTitle()))
                .andExpect(jsonPath("$.description").value(expectedResponse.getDescription()))
                .andExpect(jsonPath("$.status").value(expectedResponse.getStatus()));
    }


    /**
     * Publish your Tutorial via id
     */

    // Method to provide test cases for parameterized tests
    private static Stream<Arguments> provideTutorialIds() {
        return Stream.of(
                Arguments.of(1L, true),  // Successful publish
                Arguments.of(2L, false)  // Failure case (e.g., already published)
        );
    }

    @ParameterizedTest
    @MethodSource("provideTutorialIds")
    public void testPublishTutorial(long id, boolean expectedStatus) throws Exception {
        // Mock the service method to return a status based on input id
        when(tutorialService.tutorialPublishedById(id)).thenReturn(expectedStatus);

        // Create the expected response map
        Map<String, Object> expectedResponse = new HashMap<>();
        expectedResponse.put("status", expectedStatus);
        expectedResponse.put("message", "Tutorial published successfully");

        // Perform the PUT request and assert the results
        mockMvc.perform(put("/api/platform/v1/tutorials/publish/{id}", id)
                        .contentType(MediaType.APPLICATION_JSON)
                )
                .andExpect(status().isAccepted())
                .andExpect(jsonPath("$.status").value(expectedStatus))
                .andExpect(jsonPath("$.message").value("Tutorial published successfully"));
    }

    /**
     * UnPublish your Tutorial via id
     */

    @Test
    public void testUnpublishTutorial_Success() throws Exception {
        // Arrange
        when(tutorialService.tutorialUnPublishedById(1L)).thenReturn(true);

        // Act & Assert
        mockMvc.perform(put("/api/platform/v1/tutorials/unpublish/{id}", 1)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.status").value(true))
                .andExpect(jsonPath("$.message").value("Tutorial unpublished successfully"));
    }

    @Test
    public void testUnpublishTutorial_NotFound() throws Exception {
        // Arrange
        when(tutorialService.tutorialUnPublishedById(999L)).thenReturn(false);

        // Act & Assert
        mockMvc.perform(put("/api/platform/v1/tutorials/unpublish/{id}", 999)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.status").value(false))
                .andExpect(jsonPath("$.message").value("Tutorial not found"));
    }


    /**
     * Load published all
     * @throws Exception
     */
    @Test
    public void testGetTutorialPublished_SuccessAll() throws Exception {
        // Arrange
        List<TutorialResponse> tutorials = Arrays.asList(
                new TutorialResponse(1L, "Tutorial 1","desc", true),
                new TutorialResponse(2L, "Tutorial 2","descr", true)
        );
        when(tutorialService.getTutorialPublished()).thenReturn(tutorials);

        // Act & Assert
        mockMvc.perform(get("/api/platform/v1/tutorials/published")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$[0].id").value(1L))
                .andExpect(jsonPath("$[0].title").value("Tutorial 1"))
                .andExpect(jsonPath("$[1].id").value(2L))
                .andExpect(jsonPath("$[1].title").value("Tutorial 2"));
    }



    /**
     * Load test cases from test.json and get all the published list
     */

    public static List<TutorialResponse> testData() throws Exception {
        ObjectMapper objectMapper = new ObjectMapper();
        return objectMapper.readValue(new File("src/test/resources/test.json"), new TypeReference<List<TutorialResponse>>() {});
    }

    @ParameterizedTest
    @MethodSource("testData")
    public void testGetTutorialPublished_Success(TutorialResponse tutorial) throws Exception {
        // Arrange
        List<TutorialResponse> tutorials = List.of(tutorial);
        when(tutorialService.getTutorialPublished()).thenReturn(tutorials);

        /* Act & Assert //for only zero index means:   {
            "id": 1,
            "title": "Introduction to Java",
            "description": "A beginner's guide to Java programming.",
            "status": true
          }only*/

        mockMvc.perform(get("/api/platform/v1/tutorials/published")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$[0].id").value(tutorial.getId()))
                .andExpect(jsonPath("$[0].title").value(tutorial.getTitle()))
                .andExpect(jsonPath("$[0].description").value(tutorial.getDescription()))
                .andExpect(jsonPath("$[0].status").value(tutorial.getStatus()));

        // Assert this will handle all entries in side test.json
        for (int i = 0; i < tutorials.size(); i++) {
            mockMvc.perform(get("/api/platform/v1/tutorials/published"))
                    .andExpect(jsonPath(String.format("$[%d].id", i)).value(tutorials.get(i).getId()))
                    .andExpect(jsonPath(String.format("$[%d].title", i)).value(tutorials.get(i).getTitle()))
                    .andExpect(jsonPath(String.format("$[%d].description", i)).value(tutorials.get(i).getDescription()))
                    .andExpect(jsonPath(String.format("$[%d].status", i)).value(tutorials.get(i).getStatus()));
        }

    }



}









